<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Diagonal SVG Generator</title>
        <meta http-equiv="Content-Type" content="image/svg+xml" />
    </head>
    <body>
        <div id="content"></div>
        <script>
            const defaults = {
                width: 500,
                height: 500,
                rowTiles: 10, // Further reduced from 10 to 8 for testing
                colTiles: 10, // Further reduced from 10 to 8 for testing
                format: "svg\0",
            };

            const urlParams = new URLSearchParams(window.location.search);
            const config = {
                width: parseInt(urlParams.get("width")) || defaults.width,
                height: parseInt(urlParams.get("height")) || defaults.height,
                rowTiles:
                    parseInt(urlParams.get("row_tiles")) || defaults.rowTiles,
                colTiles:
                    parseInt(urlParams.get("col_tiles")) || defaults.colTiles,
                format: defaults.format,
            };

            // Simple fetch for wasm
            fetch("./diagonal.wasm")
                .then((response) => response.arrayBuffer())
                .then((bytes) =>
                    WebAssembly.instantiate(bytes, {
                        wasi_snapshot_preview1: {
                            proc_exit: () => {},
                            fd_close: () => 0,
                            fd_write: () => 0,
                            fd_seek: () => 0,
                            fd_read: () => 0,
                            environ_sizes_get: () => 0,
                            environ_get: () => 0,
                        },
                        env: {
                            // Add memory import if needed
                            memory: new WebAssembly.Memory({ initial: 10 }), // 10 pages (640KB)
                        },
                    })
                )
                .then((result) => {
                    console.log("WASM module loaded", result);
                    const instance = result.instance;

                    // Log available exports
                    console.log(
                        "Available exports:",
                        Object.keys(instance.exports)
                    );

                    // Get references to the exported functions and memory
                    const generate_image =
                        instance.exports._generate_image ||
                        instance.exports.generate_image;
                    const memory =
                        instance.exports.memory || instance.imports.env.memory;

                    if (!generate_image) {
                        document.getElementById("content").textContent =
                            "Error: generate_image function not found in WASM module";
                        return;
                    }

                    // Log memory size
                    console.log(
                        `Memory size: ${memory.buffer.byteLength} bytes`
                    );

                    // Grow memory if needed to ensure enough space
                    const currentPages = memory.buffer.byteLength / 65536;
                    const requiredPages = Math.ceil((100000 + 4096) / 65536);
                    if (currentPages < requiredPages) {
                        try {
                            memory.grow(requiredPages - currentPages);
                            console.log(
                                `Memory grown to ${memory.buffer.byteLength} bytes`
                            );
                        } catch (e) {
                            console.warn("Failed to grow memory:", e);
                        }
                    }

                    // Set up buffer with larger size
                    const bufferSize = 100000; // Increased from 60000
                    const bufferPtr = 1024; // Start buffer at a safe offset

                    // Format pointer - use a separate location in memory
                    const formatStringBytes = new TextEncoder().encode(
                        config.format
                    );
                    const formatPtr = bufferSize + 100; // Place format string after buffer with padding

                    // Copy format string to memory
                    const memView = new Uint8Array(memory.buffer);
                    formatStringBytes.forEach((byte, i) => {
                        memView[formatPtr + i] = byte;
                    });

                    try {
                        // Calculate a safe buffer size based on the number of tiles
                        // Each tile needs approximately 120 bytes for the SVG line element
                        const estimatedSize =
                            1000 + config.rowTiles * config.colTiles * 120;
                        const actualBufferSize = Math.min(
                            bufferSize,
                            estimatedSize
                        );

                        console.log(
                            `Estimated buffer size needed: ${estimatedSize} bytes`
                        );
                        console.log(
                            `Using buffer size: ${actualBufferSize} bytes`
                        );

                        // Call the generate_image function
                        console.log("Calling generate_image with parameters:", {
                            width: config.width,
                            height: config.height,
                            rowTiles: config.rowTiles,
                            colTiles: config.colTiles,
                            formatPtr,
                            bufferPtr,
                            actualBufferSize,
                        });

                        const length = generate_image(
                            config.width,
                            config.height,
                            config.rowTiles,
                            config.colTiles,
                            formatPtr,
                            bufferPtr,
                            actualBufferSize
                        );

                        console.log(
                            `SVG generation result: length = ${length}`
                        );

                        if (length >= 0) {
                            // Create a view into the memory buffer
                            const memoryBuffer = new Uint8Array(
                                memory.buffer,
                                bufferPtr,
                                length
                            );
                            const svgString = new TextDecoder().decode(
                                memoryBuffer
                            );

                            console.log("SVG string length:", svgString.length);
                            console.log(
                                "SVG string preview:",
                                svgString.substring(0, 100) + "..."
                            );

                            // Display SVG in the content div instead of replacing the whole document
                            document.getElementById("content").innerHTML =
                                svgString;
                        } else {
                            // More detailed error for buffer overflow
                            if (length === -1) {
                                document.getElementById("content").innerHTML = `
                                <div style="margin: 20px; color: red;">
                                    <h2>Buffer Overflow Error</h2>
                                    <p>The SVG content is too large for the allocated buffer.</p>
                                    <h3>Troubleshooting:</h3>
                                    <ul>
                                        <li>Try reducing the number of tiles (current: ${config.rowTiles}x${config.colTiles})</li>
                                        <li>Try accessing with fewer tiles: <a href="diagonal.html?row_tiles=5&col_tiles=5">Use 5x5 tiles</a></li>
                                        <li>Estimated space needed: ${estimatedSize} bytes</li>
                                        <li>Buffer allocated: ${actualBufferSize} bytes</li>
                                    </ul>
                                </div>`;
                            } else {
                                document.getElementById(
                                    "content"
                                ).textContent = `Error: Generation failed (code: ${length})`;
                            }
                        }
                    } catch (error) {
                        console.error("Error during WASM execution:", error);
                        document.getElementById("content").textContent =
                            "Error during WASM execution: " + error.message;
                    }
                })
                .catch((error) => {
                    console.error("Error loading WASM:", error);
                    document.getElementById(
                        "content"
                    ).innerHTML = `<div style="color: red; padding: 20px;">
                        <h2>Error loading WASM:</h2>
                        <p>${error.message}</p>
                        <h3>Debugging Information:</h3>
                        <pre>Config: ${JSON.stringify(config, null, 2)}</pre>
                    </div>`;
                });
        </script>
    </body>
</html>
